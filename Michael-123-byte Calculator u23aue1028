import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class ScientificCalculator extends JFrame implements ActionListener {

    private JTextField display;
    private String currentInput = "";
    private boolean isRadians = false;
    private boolean clearDisplayOnNextInput = false;

    public ScientificCalculator() {
        setTitle("Scientific Calculator");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new BorderLayout());
        setPreferredSize(new Dimension(400, 600));

        display = new JTextField("0");
        display.setHorizontalAlignment(JTextField.RIGHT);
        display.setFont(new Font("Arial", Font.PLAIN, 24));
        display.setEditable(false);
        display.setBorder(new EmptyBorder(10, 10, 10, 10));
        add(display, BorderLayout.NORTH);

        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new GridLayout(0, 5, 5, 5)); // Grid layout, 5 columns, dynamic rows
        buttonPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

        String[] buttonLabels = {
                "AC", "C", "%", "/", "*",
                "7", "8", "9", "-", "(",
                "4", "5", "6", "+", ")",
                "1", "2", "3", "^", "√",
                "0", ".", "=", "π", "e",
                "sin", "cos", "tan", "log", "ln",
                "sin⁻¹", "cos⁻¹", "tan⁻¹", "10^x", "e^x",
                "x!", "x^y", "n√x", "Rad/Deg",
        };

        for (String label : buttonLabels) {
            JButton button = new JButton(label);
            button.setFont(new Font("Arial", Font.PLAIN, 16));
            button.addActionListener(this);
            buttonPanel.add(button);
        }

        add(buttonPanel, BorderLayout.CENTER);
        pack();
        setLocationRelativeTo(null); // Center on screen
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        String command = e.getActionCommand();

        if (clearDisplayOnNextInput) {
            currentInput = "";
            display.setText("");
            clearDisplayOnNextInput = false;
        }

        switch (command) {
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
            case ".":
                currentInput += command;
                display.setText(currentInput);
                break;
            case "+":
            case "-":
            case "*":
            case "/":
            case "%":
            case "^":
                currentInput += command;
                display.setText(currentInput);
                break;
            case "(":
            case ")":
                currentInput += command;
                display.setText(currentInput);
                break;
            case "π":
                currentInput += Math.PI;
                display.setText(currentInput);
                break;
            case "e":
                currentInput += Math.E;
                display.setText(currentInput);
                break;
            case "√":
                currentInput += "sqrt(";
                display.setText(currentInput);
                break;
            case "log":
                currentInput += "log10(";
                display.setText(currentInput);
                break;
            case "ln":
                currentInput += "ln(";
                display.setText(currentInput);
                break;
            case "sin":
                currentInput += "sin(";
                display.setText(currentInput);
                break;
            case "cos":
                currentInput += "cos(";
                display.setText(currentInput);
                break;
            case "tan":
                currentInput += "tan(";
                display.setText(currentInput);
                break;
            case "sin⁻¹":
                currentInput += "asin(";
                display.setText(currentInput);
                break;
            case "cos⁻¹":
                currentInput += "acos(";
                display.setText(currentInput);
                break;
            case "tan⁻¹":
                currentInput += "atan(";
                display.setText(currentInput);
                break;
            case "10^x":
                currentInput += "pow10(";
                display.setText(currentInput);
                break;
            case "e^x":
                currentInput += "exp(";
                display.setText(currentInput);
                break;
            case "x!":
                currentInput += "fact(";
                display.setText(currentInput);
                break;
            case "x^y":
                currentInput += "^("; // Using ^ as operator for x^y in input string
                display.setText(currentInput);
                break;
            case "n√x":
                currentInput += "nrt("; // nrt(n, x) for nth root of x
                display.setText(currentInput);
                break;
            case "Rad/Deg":
                isRadians = !isRadians;
                ((JButton) e.getSource()).setText(isRadians ? "Radians" : "Degrees"); // Toggle button text
                break;
            case "=":
                try {
                    String result = evaluateExpression(currentInput);
                    display.setText(result);
                    currentInput = result;
                    clearDisplayOnNextInput = true; // Clear after showing result
                } catch (ArithmeticException ex) {
                    display.setText("Error: " + ex.getMessage());
                    currentInput = "";
                    clearDisplayOnNextInput = true;
                } catch (Exception ex) {
                    display.setText("Error: Invalid Expression");
                    currentInput = "";
                    clearDisplayOnNextInput = true;
                }
                break;
            case "C":
                currentInput = "";
                display.setText("0");
                break;
            case "AC":
                currentInput = "";
                display.setText("0");
                isRadians = false;
                // Reset Rad/Deg button text if needed, though it's probably better to keep the toggle state.
                for (Component comp : ((JPanel)getContentPane().getComponent(1)).getComponents()) { // A bit hacky to find the button
                    if (comp instanceof JButton && ((JButton) comp).getText().equals("Radians")) {
                        ((JButton) comp).setText("Degrees");
                        break;
                    } else if (comp instanceof JButton && ((JButton) comp).getText().equals("Degrees")) {
                        break; // Already in Degrees state, no need to change
                    }
                }

                break;
        }
    }

    private String evaluateExpression(String expression) {
        try {
            return String.valueOf(ShuntingYardCalculator.evaluate(expression, isRadians));
        } catch (Exception e) {
            throw new ArithmeticException(e.getMessage()); // Re-throw as ArithmeticException for display
        }
    }


    public static void main(String[] args) {
        SwingUtilities.invokeLater(ScientificCalculator::new);
    }
}


class ShuntingYardCalculator {

    public static double evaluate(String expression, boolean isRadians) {
        List<String> postfixTokens = infixToPostfix(expression);
        return evaluatePostfix(postfixTokens, isRadians);
    }

    private static List<String> infixToPostfix(String expression) {
        List<String> postfixTokens = new ArrayList<>();
        Stack<String> operatorStack = new Stack<>();
        StringBuilder numberBuffer = new StringBuilder();
        StringBuilder functionBuffer = new StringBuilder();

        for (int i = 0; i < expression.length(); i++) {
            char c = expression.charAt(i);

            if (Character.isDigit(c) || c == '.') {
                numberBuffer.append(c);
            } else if (Character.isLetter(c)) {
                functionBuffer.append(c);
            } else {
                // Process any pending number
                if (numberBuffer.length() > 0) {
                    postfixTokens.add(numberBuffer.toString());
                    numberBuffer.setLength(0);
                }

                // Process any pending function name
                if (functionBuffer.length() > 0) {
                    operatorStack.push(functionBuffer.toString());
                    functionBuffer.setLength(0);
                }

                if (c == '(') {
                    operatorStack.push("(");
                } else if (c == ')') {
                    boolean foundMatch = false;
                    while (!operatorStack.isEmpty()) {
                        String top = operatorStack.pop();
                        if (top.equals("(")) {
                            foundMatch = true;
                            // If there's a function on top of the stack, add it to output
                            if (!operatorStack.isEmpty() && isFunction(operatorStack.peek())) {
                                postfixTokens.add(operatorStack.pop());
                            }
                            break;
                        } else {
                            postfixTokens.add(top);
                        }
                    }
                    if (!foundMatch) {
                        throw new IllegalArgumentException("Mismatched parentheses");
                    }
                } else if (c == ',') {
                    while (!operatorStack.isEmpty() && !operatorStack.peek().equals("(")) {
                        postfixTokens.add(operatorStack.pop());
                    }
                } else if (isOperator(String.valueOf(c))) {
                    String operator = String.valueOf(c);
                    while (!operatorStack.isEmpty() && isOperator(operatorStack.peek()) &&
                            getPrecedence(operatorStack.peek()) >= getPrecedence(operator)) {
                        postfixTokens.add(operatorStack.pop());
                    }
                    operatorStack.push(operator);
                }
            }
        }

        // Process any remaining number or function
        if (numberBuffer.length() > 0) {
            postfixTokens.add(numberBuffer.toString());
        }
        if (functionBuffer.length() > 0) {
            operatorStack.push(functionBuffer.toString());
        }
